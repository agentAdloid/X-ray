[{"/home/agenta/Desktop/Adloid/x-ray/src/index.js":"1","/home/agenta/Desktop/Adloid/x-ray/src/reportWebVitals.js":"2","/home/agenta/Desktop/Adloid/x-ray/src/App.js":"3","/home/agenta/Desktop/Adloid/x-ray/src/components/XrayConfigurator.js":"4","/home/agenta/Desktop/Adloid/x-ray/src/components/Xray/Xray.js":"5","/home/agenta/Desktop/Adloid/x-ray/src/hoc/Aux.js":"6","/home/agenta/Desktop/Adloid/x-ray/src/UI/Button.js":"7"},{"size":500,"mtime":1621595601469,"results":"8","hashOfConfig":"9"},{"size":362,"mtime":1621595601469,"results":"10","hashOfConfig":"9"},{"size":202,"mtime":1621597034563,"results":"11","hashOfConfig":"9"},{"size":671,"mtime":1621602461100,"results":"12","hashOfConfig":"9"},{"size":10637,"mtime":1621675363839,"results":"13","hashOfConfig":"9"},{"size":59,"mtime":1621600588450,"results":"14","hashOfConfig":"9"},{"size":216,"mtime":1621601589365,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"2ces1a",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"/home/agenta/Desktop/Adloid/x-ray/src/index.js",[],["32","33"],"/home/agenta/Desktop/Adloid/x-ray/src/reportWebVitals.js",[],"/home/agenta/Desktop/Adloid/x-ray/src/App.js",[],"/home/agenta/Desktop/Adloid/x-ray/src/components/XrayConfigurator.js",[],"/home/agenta/Desktop/Adloid/x-ray/src/components/Xray/Xray.js",["34","35","36"],"\nimport React, {Component} from 'react';\nimport './Xray.css';\nimport Aux from '../../hoc/Aux';\nimport Button from '../../UI/Button';\nexport default class XRay extends Component{\n    constructor(props){\n        super(props);\n        //console.log('hi');\n        //console.log('bi');\n        this.state = {\n            transform: true,\n            images: this.props.images,\n            cursor: this.props.cursor || false,\n            diameter: this.props.diameter || 150,\n            beyond: this.props.beyond || false,\n            width: null,\n            height: null,\n            dim: null,\n            type: this.props.type || 'circle',\n            sensor: {\n                width: null,\n                height: null,\n                top: null,\n                left: null\n            },\n            responsive: this.props.responsive || false,\n            resize: this.props.resize || [\n                {\n                    screen: 1199,\n                    diameter: 130\n                },\n                {\n                    screen: 991,\n                    diameter: 100\n                },\n                {\n                    screen: 767,\n                    diameter: 80\n                },\n                {\n                    screen: 575,\n                    diameter: 50\n                }\n            ],\n            centerX: 0 ,\n            centerY: 0\n        };\n        this.move = this.move.bind(this);\n    }\n\n    componentDidMount = () =>{\n        this.updateWidthHeight();\n        window.addEventListener('resize', this.updateWidthHeight);\n    };\n\n    /**\n     * get diameter\n     * @returns {*}\n     */\n\n    getDiameter = () => {\n        let {diameter, resize} = this.state;\n        let getMaxResWidth = this.getMaxResize(resize);\n        let newDiameter = this.matchesWindow(resize);\n        if(this.state.responsive){\n            if(window.matchMedia(`(min-width: ${getMaxResWidth + 1}px)`).matches){\n                return (newDiameter > diameter)?(newDiameter):(diameter);\n            }else{\n                return newDiameter;\n            }\n        }else{\n            return diameter;\n        }\n    };\n\n    /**\n     * update width and height\n     */\n\n    updateWidthHeight = () => {\n        let {beyond} = this.state;\n        let naturalWidth = this.firstImg.naturalWidth;\n        let naturalHeight = this.firstImg.naturalHeight;\n        let percent = naturalWidth / naturalHeight;\n        percent = 1.61;\n        let width = this.firstImg.clientWidth;\n        let height = Math.round((width / percent));\n        let dim = this.getDiameter();\n        //console.log(window.screen.width);\n        let centerX = 0;\n        let centerY = 0;\n        let sensor;\n        if(beyond){\n            sensor = {\n                width: width + dim,\n                height: height + dim,\n                top: -(dim / 2),\n                left: -(dim / 2)\n            }\n        }else{\n            sensor = {\n                width: width,\n                height: height,\n                top: 0,\n                left: 0\n            }\n        }\n        centerY = Math.round(height/2)+Math.round(dim/2);\n        centerX = Math.round(width/2)+Math.round(dim/2);\n        console.log(centerX + \" cc \" + centerY + percent);\n        // console.log(width + ' ' + height + ' ' + dim);\n        this.setState({\n            width,\n            height,\n            dim,\n            sensor,\n            centerX,\n            centerY\n        });\n    };\n\n    /**\n     * get max width for diameter\n     * @param diameter\n     * @returns {number|Screen}\n     */\n\n    getMaxResize = (diameter) => {\n        let newDiameter = diameter[0].screen;\n        for(let i = 0; i < diameter.length; i++){\n            if(diameter[i].screen > newDiameter){\n                newDiameter = diameter[i].screen;\n            }\n        }\n        return newDiameter;\n    };\n\n    /**\n     * @param diameter\n     * @returns {number|Screen}\n     */\n\n    matchesWindow = (diameter) => {\n        let newDiameter = diameter[0].diameter;\n        for(let i = 0; i < diameter.length; i++){\n            if(window.matchMedia(`(max-width: ${diameter[i].screen}px)`).matches){\n                newDiameter = diameter[i].diameter;\n            }\n        }\n        return newDiameter;\n    };\n\n    /**\n     * hover sensor get position zoom and photo\n     * @param event\n     */\n\n    HoverSensor = (event) => {\n\n        let positionX = event.layerX ;\n        let positionY = event.layerY ;\n        console.log(\"x\" + event.layerX);\n        console.log(\"y\" + event.layerY);\n        let {sensor, dim, beyond} = this.state;\n\n        let position = {\n            startY: 0,\n            endY: sensor.height,\n            startX: 0,\n            endX: sensor.width\n        };\n\n        let coefficient = dim / 2;\n\n        let zoomPosition;\n\n        if(beyond){\n            zoomPosition = dim / 2;\n        }else{\n            zoomPosition = 0;\n        }\n\n        if((positionY >= position.startY + coefficient) && (positionY <= position.endY - coefficient)){\n            this.zoom.style.top = `${positionY - coefficient - zoomPosition}px`;\n            this.lastImg.style.top = `${-positionY + coefficient + zoomPosition}px`;\n        }else if(positionY < position.startY + coefficient){\n            this.zoom.style.top = `${position.startY - zoomPosition}px`;\n            this.lastImg.style.top = `${position.startY + zoomPosition}px`;\n        }else if(positionY > position.endY - coefficient){\n            this.zoom.style.top = `${position.endY - dim - zoomPosition}px`;\n            this.lastImg.style.top = `${-position.endY + dim + zoomPosition}px`;\n        }\n\n        if((positionX >= position.startX + coefficient) && (positionX <= position.endX - coefficient)){\n            this.zoom.style.left = `${positionX - coefficient - zoomPosition}px`;\n            this.lastImg.style.left = `${-positionX + coefficient + zoomPosition}px`;\n        }else if(positionX < position.startX + coefficient){\n            this.zoom.style.left = `${position.startX - zoomPosition}px`;\n            this.lastImg.style.left = `${position.startX + zoomPosition}px`;\n        }else if(positionX > position.endX - coefficient){\n            this.zoom.style.left = `${position.endX - dim - zoomPosition}px`;\n            this.lastImg.style.left = `${-position.endX +  dim + zoomPosition}px`;\n        }\n        this.setState({centerX:event.layerX,centerY:event.layerY});\n       // console.log(this.zoom.style.left + ' xx  ' + positionX + ' endxx' + position.endX);\n        //console.log(this.zoom.style.top + ' yy ' + positionY + 'endyy' + position.endY);\n    };\n\n    /**\n     * move mouse\n     * @param event\n     */\n\n    move = (event) => {\n        let {transform} = this.state;\n        if(transform){\n            this.setState({\n                transform: false\n            });\n        }\n\n        this.HoverSensor(event);\n    };\n    onLeftPress = () =>{\n        if(this.state.centerX+Math.round(this.state.dim/2)<=0)\n        {   return ;\n        }\n        this.move({\n            layerX:this.state.centerX-10,\n            layerY:this.state.centerY\n            });\n    }\n    onRightPress = () =>{\n        if(this.state.centerX >=Math.round(this.state.width)+Math.round(this.state.dim/2))\n        {   return ;\n        }\n        this.move({\n            layerX:this.state.centerX+10,\n            layerY:this.state.centerY\n            });\n    }\n    onTopPress = () =>{\n        if(this.state.centerY+Math.round(this.state.dim/2)<=0)\n        {   return ;\n        }\n        this.move({\n            layerX:this.state.centerX,\n            layerY:this.state.centerY-10\n            });\n    }\n    onBottomPress = () =>{\n        if(this.state.centerX >=Math.round(this.state.height)+Math.round(this.state.dim/2))\n        {   return ;\n        }\n        this.move({\n            layerX:this.state.centerX,\n            layerY:this.state.centerY+10\n            });\n    }\n    render(){\n        let {\n            images,\n            cursor,\n            transform,\n            width,\n            height,\n            dim,\n            sensor,\n            type\n        } = this.state;\n        let parentClass = (cursor)?('x-ray-photo-parent'):('x-ray-photo-parent cursor-none');\n        let parentTransform = (transform)?('x-ray-last-photo transform'):('x-ray-last-photo');\n        let lastImage = (transform)?('x-ray-last-photo-img transform'):('x-ray-last-photo-img');\n        let lastStyle = {\n            width: `${dim}px`,\n            height: `${dim}px`\n        };\n        return(\n            <Aux>\n            <div className={parentClass}>\n                <img\n                    ref={(img)=>{\n                        this.firstImg = img;\n                        console.log('firstImg is accesable');\n                        //console.log(\"image1\");\n                        //if(img!=null)\n                        // {console.log(this.firstImg.style.top);\n                        // console.log(this.firstImg.style.left);\n                        //}\n                    }}\n                    src={images[0]}\n                    alt=\"first-photo\"\n                    className=\"x-ray-first-photo\"\n                />\n                <div\n                    ref={(zoom)=>{\n                        this.zoom = zoom;\n                        //console.log(zoom);\n                    }}\n                    className={parentTransform}\n                    style={lastStyle}\n                >\n                    {\n                        (type === 'magnifyingGlass')?(\n                            <div className=\"magnifyingGlass\"></div>\n                        ):(null)\n                    }\n                    <div className=\"x-ray-last-photo-img-parent\">\n                        <img\n                            ref={(img)=>{\n                                this.lastImg = img;\n                                ///console.log(img + \"image2\");\n                            }}\n                            style={{width: `${width}px`, height: `${height}px`}}\n                            src={images[1]}\n                            alt=\"last-photo\"\n                            className={lastImage}\n                        />\n                    </div>\n                </div>\n                {/* <div className=\"x-ray-sensor\" style={sensor} onMouseMove={this.move}></div> */}\n            </div>\n            <div className=\"Buttons\">\n                <Button clicked={this.onLeftPress}>Left</Button>\n                <Button clicked={this.onRightPress}>Right</Button>\n                <Button clicked={this.onBottomPress}>Bottom</Button>\n                <Button clicked={this.onTopPress}>Top</Button>\n            </div>\n            </Aux>\n        );\n    }\n}","/home/agenta/Desktop/Adloid/x-ray/src/hoc/Aux.js",[],"/home/agenta/Desktop/Adloid/x-ray/src/UI/Button.js",[],{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":269,"column":13,"nodeType":"43","messageId":"44","endLine":269,"endColumn":19},{"ruleId":"45","severity":1,"message":"46","line":282,"column":17,"nodeType":"47","endLine":295,"endColumn":19},{"ruleId":"45","severity":1,"message":"46","line":310,"column":25,"nodeType":"47","endLine":319,"endColumn":27},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],"no-unused-vars","'sensor' is assigned a value but never used.","Identifier","unusedVar","jsx-a11y/img-redundant-alt","Redundant alt attribute. Screen-readers already announce `img` tags as an image. You don’t need to use the words `image`, `photo,` or `picture` (or any specified custom words) in the alt prop.","JSXOpeningElement","no-global-assign","no-unsafe-negation"]